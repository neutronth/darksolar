///
/// $Release: 0.2.0 $
/// $Copyright: copyright(c) 2011 kuwata-lab.com all rights reserved $
/// $License: MIT License $

/**
 *  cmdopt.js -- command-line option parser for Node.js
 *
 *  see https://bitbucket.org/kwatch/cmdopt/wiki/Cmdopt.js for details.
 */

"use strict";


var VERSION = '$Release: 0.2.0 $'.split(/ /)[1];


function _repeat(str, n) {
  var s = "";
  for (var i = 0; i < n; i++) s += str;
  return s;
}


function _fill(str, width, ch) {
  return str + _repeat(ch, width - str.length);
}


function Schema() {
  this.items = [];
  this._itemsTable = {};
}

(function(def) {

  def.add = function add(options, desc, validator, handler) {
    var attr = null;
    var m = options.match(/^(.*?) *#(\w+)$/);
    if (m) { options = m[1]; attr = m[2]; }
    var a = this._parseOptions(options);
    if (! attr) attr = a[1] || a[0];
    if (handler == null) handler = function(opts, val) { opts[attr] = val; };
    options = options.replace(/ *#\w+$/, '');
    var item = { short: a[0], long: a[1], arg: a[2], required: a[3], attr: attr,
                 options: options, desc: desc, validator: validator, handler: handler };
    this.items.push(item);
    if (item.short) this._itemsTable["-" + item.short] = item;
    if (item.long)  this._itemsTable["--" + item.long] = item;
    return item;
  };

  def._parseOptions = function _parseOptions(options) {
    var rexp1 = /^ *-(\w), *--(\w[-\w]*)(?:=(.*)|\[=(.*)\])?$/;
    var rexp2 = /^ *-(\w)(?: +(\S*)|\[=(.*)\])?$/;
    var rexp3 = /^ *--(\w[-\w]*)(?:=(.*)|\[=(.*)\])?$/;
    var m;
    if      ((m = options.match(rexp1))) /* pass */;
    else if ((m = options.match(rexp2))) m.splice(2, 0, null);
    else if ((m = options.match(rexp3))) m.splice(1, 0, null);
    else throw new Error("add('" + options + "'): invalid option definition.");
    var arg = m[3] ? m[3] : m[4] ? "[" + m[4] + "]" : null;
    return [ m[1], m[2], m[3] || m[4], !!m[3] ];
  };

  def.get = function get(opt) { return this._itemsTable[opt]; };

  def.help = function help(width, indent) {
    var arr = [], items = this.items, n = items.length, i;
    if (width == null) {
      width = 0;
      for (i = 0; i < n; i++) {
        var len = items[i].options.length;
        if (len > width) width = len;
      }
      width++;
      var max = 20;
      if (width > max) width = max;
    }
    if (indent == null) indent = "  ";
    var buf = "";
    for (i = 0; i < n; i++) if (items[i].desc) {
      buf += indent + _fill(items[i].options, width, " ") + ": " + items[i].desc + "\n";
    }
    return buf;
  };

  //def._initializeOpts = function _initializeOpts(opts) {
  //  var items = this.items;
  //  for (var i = 0, n = items.length; i < n; i++) {
  //    var attr = items[i].attr;
  //    if (! (attr in opts)) opts[attr] = null;
  //  }
  //};

})(Schema.prototype);


function Builder(item) {
  this._item = item;
}

(function(def) {

  def.getItem = function getItem(args) { return this._item; };

  def.validation = function validation(func) {
    this._item.validator = func;
    return this;
  };

  def.action = function action(func) {
    this._item.handler = func;
    return this;
  };

})(Builder.prototype);


function Parser(schema) {
  this.schema = new Schema();
}

(function(def) {

  def.option = function option(options, desc) {
    var item = this.schema.add(options, desc);
    return new Builder(item);
  };

  def.help = function help(width, indent) {
    return this.schema.help(width, indent);
  };

  def.parse = function parse(args, defaults) {
    var opts = defaults == null ? {} : Object.create(defaults);
    //this.schema.initializeOpts(opts);
    while (args.length > 0) {
      var arg = args.shift();
      if      (arg === "--")     break;
      else if (arg.match(/^--/)) this._parseLong(arg, opts);
      else if (arg.match(/^-/))  this._parseShort(arg, args, opts);
      else {
        args.unshift(arg);
        break;
      }
    }
    return opts;
  };

  def._parseLong = function _parseLong(arg, opts) {
    var m = arg.match(/^--(\w[-\w]*)(?:=(.*))?$/);
    if (! m) throw new ParseError(arg + ": invalid option.");
    var name = m[1], val = m[2];
    var item = this.schema.get("--" + name);
    if (! item) throw new ParseError(arg + ": unknown option.");
    if (val == null && item.required) throw new ParseError(arg + ": argument required.");
    if (val != null && ! item.arg)    throw new ParseError(arg + ": unexpected argument.");
    if (val == null) val = true;
    this._callValidator(item, val, arg);
    this._callHandler(item, val, opts);
  };

  def._parseShort = function _parseShort(arg, args, opts) {
    for (var i = 1, n = arg.length; i < n; i++) {
      var ch = arg[i];
      var item = this.schema.get("-" + ch);
      if (! item) throw new ParseError("-" + ch + ": unknown option.");
      var val;
      if (! item.arg) {
        val = true;
      }
      else if (item.required) {
        val = arg.substr(i+1);
        if (! val) {
          if (args.length === 0) throw new ParseError("-" + ch + ": argument required.");
          val = args.shift();
        }
        i = n;
      }
      else {
        val = arg.substr(i+1) || true;
        i = n;
      }
      var optarg;
      if      (val === true)  optarg = "-" + ch;
      else if (item.required) optarg = "-" + ch + " " + val;
      else                    optarg = "-" + ch + val;
      this._callValidator(item, val, optarg);
      this._callHandler(item, val, opts);
    }
  };

  def._callValidator = function _callValidator(item, val, arg) {
    if (item.validator) {
      var errmsg = item.validator(val);
      if (errmsg) throw new ParseError(arg + ": " + errmsg);
    }
  };

  def._callHandler = function _callHandler(item, val, opts) {
    if (item.handler) item.handler(opts, val);
  };

})(Parser.prototype);


function ParseError(message) {
  Error.call(this, message);
  this.message = message;
}
//ParseError.prototype = new Error('xxx');
//delete ParseError.prototype.stack;
ParseError.prototype.__proto__ = Error.prototype;
ParseError.prototype.constructor = ParseError;


var cmdopt = exports;
cmdopt.VERSION    = VERSION;
cmdopt.Schema     = Schema;
cmdopt.Builder    = Builder;
cmdopt.ParseError = ParseError;
cmdopt.Parser     = Parser;
