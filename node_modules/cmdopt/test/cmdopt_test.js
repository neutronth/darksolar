///
/// $Release: 0.2.0 $
/// $Copyright: copyright(c) 2011 kuwata-lab.com all rights reserved $
/// $License: MIT License $
///

"use strict";

var assert = require('assert');

var cmdopt = require('../cmdopt.js');


/// custom assertion
function assertError(func, errclass, errmsg) {
  var not_thrown = false;
  try {
    func();
    not_thrown = true;
  }
  catch (ex) {
    func.exception = ex;
    assert.ok(ex instanceof errclass, "" + errclass + " expected but got " + ex);
    if (errmsg) {
      if (errmsg instanceof RegExp) {
        if (! errmsg.test(ex.message)) {
          assert.fail("Error message '" + ex.message + "' not matched to " + errmsg);
        }
      }
      else {
        assert.equal(ex.message, errmsg);
      }
    }
  }
  if (not_thrown) {
    assert.fail("Error " + errclass + " expected but not thrown.");
  }
}


/// option definitions
//var cmdopt = require('cmdopt');
var parser = new cmdopt.Parser();
parser.option("-h, --help", "show help");
parser.option("-v #version", "print version");
parser.option("-m, --mode=MODE", "set mode ('verbose' or 'quiet')")
      .validation(function(val) {
        if (val !== "verbose" && val !== "quiet")
          return "'verbose' or 'quiet' expected.";
        return null;
      });
parser.option("--quiet", "quiet mode")
      .action(function(opts, val) { opts.mode = "quiet"; });
parser.option("-i, --indent[=N]", "indent (default 2)")
      .validation(function(val) {
        if (val !== true && ! val.match(/^\d+$/))
          return "integer expected.";
        return null;
      });
parser.option("-D", "enable debug mode");


exports[__filename] = {

  "cmdopt.Schema": {

    "#add()": {
      "BEFORE": function() {
        this.schema = new cmdopt.Schema();
        this.item = this.schema.add("-m, --mode=MODE", "set mode");
      },
      "returns item object.": function() {
        var item = this.item;
        assert.equal(typeof(item), "object");
      },
      "parses command-option definition.": function() {
        var item = this.item;
        assert.equal(item.short, "m");
        assert.equal(item.long, "mode");
        assert.equal(item.arg, "MODE");
        assert.equal(item.required, true);
        assert.equal(item.attr, "mode");
        assert.equal(item.desc, "set mode");
        assert.equal(item.validator, null);
      },
      "sets default handler function.": function() {
        var item = this.item;
        assert.equal(typeof(item.handler), "function");
        var opts = {};
        item.handler(opts, "verbose");
        assert.equal(opts.mode, "verbose");
      },
      "register item object.": function() {
        var schema = this.schema, item = this.item;
        assert.equal(schema.get("-m"), item);
        assert.equal(schema.get("--mode"), item);
      },
      "throws error when option definition is invalid.": function() {
        var schema = this.schema;
        function fn() {
          schema.add("-m MODE, --mode", "set mode", function() { return 0; });
        }
        assertError(fn, Error, "add('-m MODE, --mode'): invalid option definition.");
      },
      "recognizes '#name' as option attr.": function() {
        var item = this.schema.add("-q #quiet");
        assert.equal(item.attr, "quiet");
        assert.equal(item.short, "q");
        assert.equal(item.long, null);
        //
        var item = this.schema.add("-q value #quiet");
        assert.equal(item.attr, "quiet");
        assert.equal(item.short, "q");
        assert.equal(item.long, null);
        //
        var item = this.schema.add("--silent #quiet");
        assert.equal(item.attr, "quiet");
        assert.equal(item.short, null);
        assert.equal(item.long, "silent");
      }
    },

    "#help()": {
      "returns help message of command-line options.": function() {
        var expected = (
          ""
            + "  -h, --help          : show help\n"
            + "  -v                  : print version\n"
            + "  -m, --mode=MODE     : set mode ('verbose' or 'quiet')\n"
            + "  --quiet             : quiet mode\n"
            + "  -i, --indent[=N]    : indent (default 2)\n"
            + "  -D                  : enable debug mode\n"
        );
        assert.equal(parser.schema.help(20), expected);
      },
      "takes width and indent arguments.": function() {
        var expected = (
          ""
            + "    -h, --help: show help\n"
            + "    -v        : print version\n"
            + "    -m, --mode=MODE: set mode ('verbose' or 'quiet')\n"
            + "    --quiet   : quiet mode\n"
            + "    -i, --indent[=N]: indent (default 2)\n"
            + "    -D        : enable debug mode\n"
        );
        assert.equal(parser.schema.help(10, "    "), expected);
      },
      "calculates width when not specified.": function() {
        var expected = (
          ""
            + "  -h, --help       : show help\n"
            + "  -v               : print version\n"
            + "  -m, --mode=MODE  : set mode ('verbose' or 'quiet')\n"
            + "  --quiet          : quiet mode\n"
            + "  -i, --indent[=N] : indent (default 2)\n"
            + "  -D               : enable debug mode\n"
        );
        assert.equal(parser.schema.help(), expected);
      }
    }

  },

  "cmdopt.Builder": {

    "#getItem()": {
      "returns item object.": function() {
        var item = {attr: 'help'};
        var builder = new cmdopt.Builder(item);
        assert.equal(builder.getItem(), item);
      }
    },

    "#validation()": {
      "sets validator function.": function() {
        var item = {}, builder = new cmdopt.Builder(item);
        var fn = function(val) { return "ERROR"; };
        builder.validation(fn);
        assert.equal(item.validator, fn);
      },
      "returns self.": function() {
        var item = {}, builder = new cmdopt.Builder(item);
        var fn = function(val) { return "ERROR"; };
        var ret = builder.validation(fn);
        assert.equal(ret, builder);
      }
    },

    "#action()": {
      "sets handler function.": function() {
        var item = {}, builder = new cmdopt.Builder(item);
        var fn = function(val) { return "ERROR"; };
        builder.action(fn);
        assert.equal(item.handler, fn);
      },
      "returns self.": function() {
        var item = {}, builder = new cmdopt.Builder(item);
        var fn = function(val) { return "ERROR"; };
        var ret = builder.action(fn);
        assert.equal(ret, builder);
      }
    }

  },

  "cmdopt.Parser": {

    "#option()": {
      "registers option definition.": function() {
        var parser = new cmdopt.Parser();
        parser.option("-h, --help", "show help");
        var item = parser.schema.get("-h");
        assert.equal(item.short, "h");
        assert.equal(item.long, "help");
        assert.equal(item.desc, "show help");
      },
      "returns builder object.": function() {
        var parser = new cmdopt.Parser();
        var ret = parser.option("-h, --help", "show help");
        assert.ok(ret instanceof cmdopt.Builder);
      }
    },

    "#help()": {
      "calls #schema.help().": function() {
        var parser = new cmdopt.Parser();
        var args = null;
        parser.schema = {help: function() { args = arguments; return "RET"; }};
        var ret = parser.help(19, "   ");
        assert.equal(ret, "RET");
        assert.equal(args[0], 19);
        assert.equal(args[1], "   ");
      }
    },

    "#parse()": {
      "BEFORE": function() {
        this.parser = parser;
      },
      "parses args.": function() {
        var args = ["-vmquiet", "--help", "foo", "bar"];
        var defaults = {mode: "verbose", file: "config.json"};
        var opts = this.parser.parse(args, defaults);
        assert.ok(opts !== defaults);
        assert.equal(opts.__proto__, defaults);
        assert.equal(opts.help, true);
        assert.equal(opts.version, true);
        assert.equal(opts.mode, "quiet");        // overrided
        assert.equal(opts.file, "config.json");  // not overrided
        assert.deepEqual(args, ["foo", "bar"]);
      },
      "parses long options.": function() {
        // no argument
        var args = ["--quiet", "foo", "bar"];
        var opts = this.parser.parse(args);
        assert.equal(opts.mode, "quiet");
        assert.deepEqual(args, ["foo", "bar"]);
        // required argument
        args = ["--mode=verbose", "foo", "bar"];
        opts = this.parser.parse(args);
        assert.equal(opts.mode, "verbose");
        assert.deepEqual(args, ["foo", "bar"]);
      },
      "parses short options.": function() {
        var args = ["-h", "-m", "quiet", "foo", "bar"];
        var opts = this.parser.parse(args);
        assert.equal(opts.help, true);    // no argument
        assert.equal(opts.mode, "quiet");  // required argument
        assert.deepEqual(args, ["foo", "bar"]);
      },
      "short options can be conbined.": function() {
        var args = ["-hmquiet", "foo", "bar"];
        var opts = this.parser.parse(args);
        assert.equal(opts.help, true);
        assert.equal(opts.mode, "quiet");
        assert.deepEqual(args, ["foo", "bar"]);
      },
      "optional argument is available for short option.": function() {
        // when optional argument is not passed
        var args = ["-i", "foo", "bar"];
        var opts = this.parser.parse(args);
        assert.equal(opts.indent, true);
        assert.deepEqual(args, ["foo", "bar"]);
        // when optional argument is passed
        args = ["-i3", "foo", "bar"];
        opts = this.parser.parse(args);
        assert.equal(opts.indent, "3");
        assert.equal(typeof(opts.indent), "string");
        assert.deepEqual(args, ["foo", "bar"]);
      },
      "optional argument is available for long option.": function() {
        // when optional argument is not passed
        var args = ["--indent", "foo", "bar"];
        var opts = this.parser.parse(args);
        assert.equal(opts.indent, true);
        assert.deepEqual(args, ["foo", "bar"]);
        // when optional argument is passed
        args = ["--indent=3", "foo", "bar"];
        opts = this.parser.parse(args);
        assert.equal(opts.indent, 3);
        assert.deepEqual(args, ["foo", "bar"]);
      },
      "throws error when unknown short option specified.": function() {
        var args = ["-xD", "foo", "bar"];
        var parser = this.parser;
        assertError(function() { parser.parse(args, this); },
                      cmdopt.ParseError, "-x: unknown option.");
      },
      "throws error when unknown long option specified.": function() {
        var parser = this.parser, args;
        // when argument not passed
        args = ["--SOS"];
        assertError(function() { parser.parse(args, this); },
                      cmdopt.ParseError, "--SOS: unknown option.");
        // with argument passed
        args = ["--sos=SOS"];
        assertError(function() { parser.parse(args, this); },
                      cmdopt.ParseError, "--sos=SOS: unknown option.");
      },
      "calls handler function.": function() {
        var args = ["--quiet", "foo", "bar"];
        var opts = this.parser.parse(args);
        assert.equal(opts.quiet, null);
        assert.equal(opts.mode, "quiet");
      },
      "throws error when validator returns error message.": function() {
        var parser = this.parser, args;
        // when short option
        args = ["-msilent", "foo", "bar"];
        assertError(function() { parser.parse(args, this); },
                    cmdopt.ParseError, "-m silent: 'verbose' or 'quiet' expected.");
        // when short option
        args = ["-i9.99", "foo", "bar"];
        assertError(function() { parser.parse(args, this); },
                    cmdopt.ParseError, "-i9.99: integer expected.");
        // when long option
        args = ["--indent=zero", "foo", "bar"];
        assertError(function() { parser.parse(args, this); },
                    cmdopt.ParseError, "--indent=zero: integer expected.");
      },
      "stop parsing when '--' found.": function() {
        var args = ["-h", "--", "-m", "verbose"];
        var opts = this.parser.parse(args);
        assert.deepEqual(args, ["-m", "verbose"]);
        assert.equal(opts.help, true);
        assert.equal(opts.mode, undefined);
      },
      "returns different object from defaults.": function() {
        var args = ["-Dm", "verbose", "foo", "bar"];
        var defaults = {};
        var opts = this.parser.parse(args, defaults);
        assert.ok(opts != defaults);
        assert.equal(opts.__proto__, defaults);
      }
    }

  },

  "cmdopt.ParseError": {
    "BEFORE": function() {
      this.err = new cmdopt.ParseError("SOS");
    },
    "subclass of Error": function() {
      assert.ok(this.err instanceof Error);
    },
    "#message is set.": function() {
      assert.equal(this.err.message, "SOS");
    },
    "#constructor is set.": function() {
      assert.equal(this.err.constructor, cmdopt.ParseError);
    }
  }

};



if (require.main === module) require("picotest").run(exports);
