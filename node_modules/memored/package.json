{
  "name": "memored",
  "version": "0.0.4",
  "description": "Shared in-memory module for cluster applications",
  "main": "index.js",
  "scripts": {
    "test": "gulp"
  },
  "author": {
    "name": "Paquitosoft"
  },
  "license": "MIT",
  "keywords": [
    "cache",
    "memory",
    "shared"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/PaquitoSoft/memored.git"
  },
  "bugs": {
    "url": "https://github.com/PaquitoSoft/memored/issues"
  },
  "devDependencies": {
    "async": "^0.9.0",
    "chai": "^1.9.1",
    "faker": "^1.1.0",
    "gulp": "^3.8.7",
    "gulp-mocha": "^1.0.0"
  },
  "readme": "# Memored\n\nMemored implements an in-memory shared cache to use in nodejs applications which uses [cluster](http://nodejs.org/api/cluster.html) module.\n\nLet's say you want your application to take advantage of multi-core CPUs using nodejs cluster module; you will be able to run several _isolated_ processes which shared nothing but a communication channel with parent process.\nIf you need a fast volatile cache, common solutions would create an in-memory map for every process you run, so you end up with the same data stored several times in your machine RAM.\n\nMemored uses communication channel between master process and its workers to use a unique in-memory storage, reducing the amount of memory your application would use.\n\n## Getting Started\nInstall this module with _npm_:\n```javascript\nnpm install memored\n```\n\nStore and read values is straightforward:\n```javascript\nvar cluster = require('cluster'),\n\tmemored = require('memored');\n\nif (cluster.isMaster) {\n\tcluster.fork();\n} else {\n\tvar han = {\n\t\t\tfirstname: 'Han',\n\t\t\tlastname: 'Solo'\n\t\t},\n\t\tluke = {\n\t\t\tfirstname: 'Luke',\n\t\t\tlastname: 'Skywalker'\n\t\t};\n\n\t// Store and read\n\tmemored.store('character1', han, function() {\n\t\tconsole.log('Value stored!');\n\n\t\tmemored.read('character1', function(err, value) {\n\t\t\tconsole.log('Read value:', value);\n\t\t});\n\t});\n\n\t// You can also set a ttl (milliseconds)\n\tmemored.store('character2', luke, 1000, function(err, expirationTime) {\n\t\tconsole.log('Value stored until:', new Date(expirationTime));\n\n\t\tsetTimeout(function() {\n\t\t\tmemored.read('character2', function(err, value) {\n\t\t\t\tconsole.log('Value is gone?', value === undefined);\n\n\t\t\t\tprocess.exit();\n\t\t\t});\n\t\t}, 1050);\n\t});\n}\n```\n\n## Invalidation management\nBy default, _memored_ will evict cache entries (stored with _ttl_) passively. This is, when you read an expired entry, you will get no value on return and _memored_ will delete the value from its internal cache.\n\nYou can also configure _memored_ to actively evict expired entries every N milliseconds. For this to work, you need to pass the attribute *purgeInterval* to the *setup* function.\nThis will trigger an internal function which looks for expired entries and deletes them from its internal cache.\n\nExample:\n```javascript\nvar cluster = require('cluster'),\n\tasync = require('async'),\n\tmemored = require('memored');\n\nif (cluster.isMaster) {\n\n\tcluster.fork();\n\tmemored.setup({ purgeInterval: 500});\n\n} else {\n\n\tasync.series({\n\t\tstoreValue: function(next) {\n\t\t\tmemored.store('key1', 'My simple string value', 100, next);\n\t\t},\n\t\treadCacheSize: function(next) {\n\t\t\tmemored.size(function(err, size) {\n\t\t\t\tconsole.log('Current size is 1?', size === 1);\n\t\t\t\tnext();\n\t\t\t});\n\t\t},\n\t\twait: function(next) {\n\t\t\tsetTimeout(next, 600);\n\t\t},\n\t\treadCacheSizeAgain: function(next) {\n\t\t\tmemored.size(function(err, size) {\n\t\t\t\tconsole.log('Current size is 0?', size === 0);\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t}, process.exit);\n}\n```\n\n## API\nDocumentation for every module function:\n\n\n### setup(options)\n\nThis function is used to configure _memored_.\n\n**Arguments**:\n\n- **purgeInterval** {Number} (optional): Configures and triggers _memored_ expired entries auto deletion. Value expressed in milliseconds. _It's only used when called this method from the master process of your application_.\n- **logger** {Object} (optional): In you want _memored_ to log something, you must provide an object implementing *log* and *warn* functions.\n\n**Example**:\n```javascript\nmemored.setup({\n\tpurgeInterval: 15000,\n\tlogger: console\n});\n```\n\n### store(key, value, [ttl], callback)\n\nThis function stores a value in the cache.\n_It is intended to be called from a worker process_.\n\n**Arguments**:\n\n- **key** {String} (required): Key used to lookup the entry\n- **value** {Mixed} (required): Whatever you want to store\n- **ttl** {Number} (optional): Time to live for this value in the cache (milliseconds)\n- **callback** {Function} (optional): Function to be call on store completion. Callback arguments:\n\t- _err_ {Error}: Optional error\n\t- _expirationTime_ {Number}: The timestamp of the moment when this entry will expire. If _ttl_ is not used, this value will be undefined.\n\n**Examples**:\n```javascript\nmemored.store('key1', {firstname: 'Han', lastname: 'Solo'}, function() {\n\tconsole.log('Value stored!');\n});\n\nmemored.store('key2', ['a', 'b', 'c'], 15000, function(err, expirationTime) {\n\tconsole.log('This value will expire on:', new Date(expirationTime));\n});\n```\n\n### read(key, callback)\n\nThis function reads a value from the cache.\n_It is intended to be called from a worker process_.\n\n**Arguments**:\n\n- **key** {String} (required): Key used to lookup the entry\n- **callback** {Function} (required): Function to be called on read completion. Callback arguments:\n\t- _err_ {Error}: Optional error\n\t- _value_ {Mixed}: Contents of the cached entry. If the value is not found or is expired, it will be undefined.\n\n**Example**:\n```javascript\nmemored.read('key1', function(err, value) {\n\tconsole.log('Key1 value:', value);\n});\n\nmemored.read('key1', function(err, value, expirationTime) {\n\tconsole.log('Key1 value:', value);\n\tconsole.log('Key1 expiration time:', new Date(expirationTime));\n});\n\nmemored.read('unknownKey', function(err, value) {\n\tconsole.log('No data read?', value === undefined);\n});\n```\n\n### remove(key, callback)\n\nThis function removes an entry from the cache.\n_It is intended to be called from a worker process_.\n\n**Arguments**:\n\n- **key** {String} (required): Key used to lookup the entry\n- **callback** {Function} (optional): Function to be called on read completion.\n\n**Example**:\n```javascript\nmemored.remove('key1', function() {\n\tconsole.log('Key removed from the cache.');\n});\n```\n\n### clean(callback)\n\nThis function removes all the entries from the cache.\n_It is intended to be called from a worker process_.\n\n**Arguments**:\n\n- **callback** {Function} (optional): Function to be called on read completion.\n\n**Example**:\n```javascript\nmemored.clean(function() {\n\tconsole.log('All cache entries have been deleted.');\n});\n```\n\n### size(callback)\n\nThis function returns the number of entries in the cache.\n\n**Arguments**:\n\n- **callback** {Function} (required): Function to be called on size calculation is complete. Callback arguments:\n\t- _err_ {Error}: Optional error\n\t- _size_ {Number}: The number of entries in the cache.\n\n**Example**:\n\n```javascript\nmemored.size(function(err, size) {\n\tconsole.log('Cache size:', size);\n});\n```\n\n###Â version\n\nThis is an attribute wich provides module's version number\n\n\n# Final note\nAll the callbacks first parameter is an optional error object. Actually, this param will never be an error because there is no expected error in the internal code. There's no function call that can possible throw an expected error that this module would deal with.\nThe existence of this param is to follow the *convention* about libraries callbacks in nodejs. As everybody expects this first callback parameter to be an optional one, I decided to include it.\n\n- [Nodeguide](http://nodeguide.com/style.html#callbacks)\n- [Nodejitsu](http://docs.nodejitsu.com/articles/errors/what-are-the-error-conventions)\n- [GoSquared](https://engineering.gosquared.com/node-js-error-handling-callbacks-vs-promises)\n\n\n## License\nCopyright (c) 2014 PaquitoSoft  \nLicensed under the MIT license.",
  "readmeFilename": "README.md",
  "_id": "memored@0.0.4",
  "dist": {
    "shasum": "55125088e1992e42f128a6c4bf74c1657af2a9c0"
  },
  "_from": "memored@",
  "_resolved": "https://registry.npmjs.org/memored/-/memored-0.0.4.tgz"
}
